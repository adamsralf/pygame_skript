%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Mein erstes Programm}

\lstsource{SRC/00 einführung/01 Start/start00.py}{1}{999}{python}{Mein erstes \emph{Spiel}, Version 1.0}{srcStart00}

Um Pygame verwenden zu können, muss das Modul \texttt{pygame} importiert werden (\zeiref{srcStart0001}). Danach stehen uns \glspl{konstante}, \glspl{funktion} und \glspl{klasse} des \Gls{namensraum} zur Verfügung. 

In \zeiref{srcStart0002}  wird die \Gls{umgebungsvari} gesetzt, die erstmal nichts mit Pygame zu tun hat. Vielmehr wird hier die Umgebungsvariable \texttt{SDL\_VIDEO\_WINDOW\_POS}\index{\texttt{SDL\_VIDEO\_WINDOW\_POS}}\randnotiz{SDL\_VIDEO\_\-WINDOW\_POS} des Betriebssystems gesetzt. Diese steuert die linke obere Startposition meines Fensters bezogen auf den ganzen Bildschirm. 

Pygame ist nicht nur der Aufruf von Funktionen oder die Instantiierung von Klassen, sondern vielmehr wird ein ganzes Subsystem verwendet. Dieses Subsystem muss erst noch gestartet werden. Dabei klinkt sich Pygame in die relevanten Komponenten des Betriebssystems ein, damit diese im Spiel verwendet werden können. In \zeiref{srcStart0003} wird der ganze Pygame-Motor mit \texttt{init()} \index{\texttt{pygame}!\texttt{init()}}\randnotiz{init()}angeworfen. Man könnte auch nur die Komponenten starten, die gerade gebraucht werden wie beispielsweise die Soundunterstützung mit \texttt{pygame.mixer.init()}\index{\texttt{pygame}!\texttt{mixer}!\texttt{init()}}.

Wir werden uns nur mit Spielen beschäftigen, die unmittelbar auf dem Desktop laufen. Oder anders herum: Wir werden keinen Game-Server implementieren. Daher brauchen unsere Spiele eine \emph{Spielfläche}/ein Fenster innerhalb dessen sich alles abspielt. Die Funktion \texttt{pygame.display.set\_mode()}\index{\texttt{pygame}!\texttt{display}!\texttt{set\_mode()}}\randnotiz{set\_mode()} liefert mir einen solche Spielfläche. Die Funktion bekommt in \zeiref{srcStart0005} einen(!) Übergabeparameter -- nämlich die Breite und die Höhe des Fensters als ein 2-Tupel. Unser Fenster ist also $600px$ breit und $400px$ (siehe \Gls{PX}) hoch. Als Rückgabe bekomme ich ein \texttt{pygame.Surface}-Objekt\index{\texttt{pygame}!\texttt{Surface}}, was ungefähr sowas wie ein \Gls{bitmap} ist. Dem Fenster kann ich dann noch mit \texttt{pygame.display.set\_caption()}\index{\texttt{pygame}!\texttt{display}!\texttt{set\_caption()}}\randnotiz{set\_caption()} eine Titelüberschrift verpassen (siehe \zeiref{srcStart0004}).

Das Spiel selbst -- so wie auch alle zukünftigen Spiele -- laufen innerhalb einer \Gls{mainloop}\index{Hauptprogrammschleife}\index{main loop}. Hier startet die Schleife in \zeiref{srcStart0006} und endet in \zeiref{srcStart0011}. Innerhalb dieser Schleife werden zukünftig immer drei Dinge passieren: 
\begin{enumerate}
	\item Ereignisse auslesen und verarbeiten: Wie in \zeiref{srcStart0007}f werden Maus-, Tastatur- oder Konsolenereignisse festgestellt und an die Spielelemente weitergegeben. In unserem Fall wird lediglich das Anklicken des X im Fenster oben rechts registriert.  
	\item Zustand der Spielelemente aktualisieren: Basierend auf den oben festgestellten Ereignissen und den Zuständen der Spielelemente, werden die neuen Zustände ermittelt (Spieler bewegt sich, Geschoss prallt auf, Punkte erhöhen sich etc.). In unserem Fall wird nur das Flag \texttt{running}\index{Flag} der Hauptprogrammschleife auf \false\ gesetzt.
	\item Bitmaps der Spielelemente malen: Die Spielelemente haben eine neue Position oder ein neues Aussehen und müssen deshalb neu gemalt werden. In diesem Minimalbeispiel wird lediglich \zeiref{srcStart0009} der Hintergrund der Spielfläche eingefärbt und anschließend in \zeiref{srcStart0010} der \Gls{doublebuffer}\index{Doublebuffer}\randnotiz{Doublebuffer} mit \texttt{pygame.display.flip()}\index{\texttt{pygame}!\texttt{display}!\texttt{flip()}}\randnotiz{flip()} ausgetauscht.
\end{enumerate}

Es sind noch einige Elemente unerklärt. Pygame schleust durch den Aufruf von \texttt{py\-game.\-init()} einen Horchposten in das Betriebssystem. Und zwar horcht Pygame die \emph{\Gls{messagequeue}} ab. Dort werden vom Betriebssystem alle Meldungen eingesammelt, die durch Ereignisse ausgelöst werden. Dies können \glslink{usb}{USB}-An\-schluss\-mel\-dungen, \glslink{ssd}{SSD}-Fehlermeldungen, Mausaktionen, Programmstarts bzw. -abstürze  usw. sein. Pygame fischt nun aus der Message-Queue mit Hilfe von \texttt{pygame.event.get()}\index{\texttt{pygame}!\texttt{event}!\texttt{get()}}\randnotiz{event.get()} alle Events, die das Spiel betreffen könnten heraus. Mit Hilfe einer \forSchleife\ iteriere ich nun die Ereignisse und picke die für mich interessanten heraus. 

Dabei überprüfe ich zuerst, was für ein Ereignistyp (\texttt{pygame.event.type})\index{\texttt{pygame}!\texttt{event}!\texttt{type}}\randnotiz{event.type} mir da angeboten wird. Derzeit ist für mich nur der Typ \texttt{pygame.QUIT}\randnotiz{pygame.QUIT}\index{\texttt{pygame}!\texttt{QUIT}} wichtig. Dieser Typ wird ausgelöst, wenn das Betriebssystem eine \emph{Beenden}-Nachricht an die Anwendung sendet. Falls ist nun eine solche Nachricht empfange, setzte ich das \Gls{flag}\ \texttt{running} auf \texttt{False}, so dass die Hauptprogrammschleife beendet wird.

Falls ich dieses Signal nicht empfange, läuft die Hauptprogrammschleife fröhlich weiter und füllt in \zeiref{srcStart0009} die gesamte Spielfläche mit \texttt{screen.fill()}\index{\texttt{pygame}!\texttt{Surface}!\texttt{fill()}} mit einer Farbe -- hier grün -- ein. Bitte beachten Sie, dass ähnlich wie in \zeiref{srcStart0005} die Funktion einen Übergabeparameter -- nämlich ein 3-Tupel -- erwartet. Dieses 3-Tupel kodiert die Farbe durch \glslink{rgb}{RGB}\randnotiz{RGB}-Angaben zwischen 0 und 255.

Verbleibt noch \zeiref{srcStart0010}: Dort wird die Funktion \texttt{pygame.quit()}\index{\texttt{pygame}!\texttt{quit()}}\randnotiz{quit()} aufgerufen. Diese Funktion ist quasi das Gegenteil von \texttt{pygame.init()} in \zeiref{srcStart0003}. Alle reservierten Ressourcen werden wieder freigegeben und die Pygame-Horchposten werden wieder aus dem System entfernt. Rufen Sie diese Funktion unbedingt immer am Ende Ihrer Anwendung auf; beenden Sie nicht einfach das Spiel. Der Unterschied entspricht dem einfachen Herauslaufen aus der Wohnung und dem ordnungsgemäßen Lichtausmachen und Türabschließen beim Verlassen der Wohnung.  

Wenn Sie jetzt die Anwendung starten, bekommen Sie eine schmucke grüne Spielfläche zu sehen. Beenden können Sie diese durch das Anklicken des~X im Fensterrahmen oben rechts.

\myebild{grüne_fläche.png}{0.8}{Eine einfache grüne Spielfläche}{picGrüneFläche}

Wenn wir uns das Spiel mal im Task-Manager anschauen (siehe~\abbref[vref]{picTaskManager00}), könnten wir leicht überrascht sein: Es werden rund 30\% der CPU-Zeit für dieses \emph{IchMacheJaEigentlichGarNichts}-Spiel verbraucht. 

\myebild{TaskManager00.png}{0.7}{Ressourcenverbrauch ohne Taktung}{picTaskManager00}

Wenn wir uns die Hauptprogrammschleife anschauen, sollte es allerdings nicht wirklich verwundern. Da wird ungebremst ein Bitmap auf den Bildschirm gemalt und dass ohne Unterbrechung. Besser wäre es bei jedem Schleifendurchlauf genügend Zeit zur Verfügung zu stellen, um die Ereignisse einzusammeln, die neuen Zustände zu berechnen und erst dann die Bildschirmausgabe zu generieren. Die Bildschirmausgabe selbst sollte auch nicht beliebig schnell und oft passieren, sondern in der Regel reichen 60 \gls{fps}\randnotiz{fps}, um eine Bewegung als flüssig wahrzunehmen. 

\lstsource{SRC/00 einführung/01 Start/start01.py}{1}{999}{python}{Mein erstes \emph{Spiel}, Version 1.1}{srcStart01}

In \zeiref{srcStart0101} wird zur Taktung ein \texttt{pygame.time.Clock}\randnotiz{Clock}\index{\texttt{pygame}!\texttt{time}!\texttt{Clock}}-Objekt erzeugt. Mit Hilfe dieses Objektes können verschiedene zeitbezogene Aufgaben bewältigt werden, wir brauchen das Objekt im Moment nur für die Taktung in \zeiref{srcStart0102}. Dort wird \texttt{pygame.time.Clock.\-tick()}\randnotiz{tick()}\index{\texttt{pygame}!\texttt{time}!\texttt{Clock}!\texttt{tick()}} mit einer Framerate gemessen in $fps$ aufgerufen. Diese Funktion sorgt dafür, dass die Anwendung nun mit maximal $60fps$ abläuft. Dies ist an dem deutlich reduzierten CPU-Verbrauch in \abbref[vref]{picTaskManager01} zu erkennen.

\myebild{TaskManager01.png}{0.7}{Ressourcenverbrauch mit Taktung}{picTaskManager01}

Hinweis: In der Pygame-Dokumentation wird darauf verwiesen, dass die Funktion \texttt{tick()} zwar sehr ressourcenschonend, aber etwas ungenau sei. Falls Genauigkeit aber bei der Taktung wichtig ist, wird die Funktion \texttt{tick\_busy\_loop()}\randnotiz{tick\_busy\_loop()}\index{\texttt{pygame}!\texttt{time}!\texttt{Clock}!\texttt{tick\_busy\_loop()}} empfohlen. Deren Nachteil ist, dass sie aber erheblich mehr Rechenzeit als \texttt{tick()} verbraucht.


\section{Was war neu?}

\begin{itemize}
\item \texttt{import pygame}:\\ \url{https://www.pygame.org/docs/tut/ImportInit.html}

\item \texttt{os.environ['SDL\_VIDEO\_WINDOW\_POS']}:\\
\url{https://docs.python.org/3/library/os.html#os.environ}

\item \texttt{pygame.init()}:
\index{\texttt{pygame}!\texttt{init()}}\\
\url{https://www.pygame.org/docs/ref/pygame.html#pygame.init}

\item \texttt{pygame.quit()}:
\index{\texttt{pygame}!\texttt{quit()}}\\
\url{https://www.pygame.org/docs/ref/pygame.html#pygame.quit}

\item \texttt{pygame.display.set\_mode()}:
\index{\texttt{pygame}!\texttt{display}!\texttt{set\_mode()}}\\
\url{https://www.pygame.org/docs/ref/display.html#pygame.display.set_mode}

\item \texttt{pygame.display.set\_caption()}:
\index{\texttt{pygame}!\texttt{display}!\texttt{set\_caption()}}\\
\url{https://www.pygame.org/docs/ref/display.html#pygame.display.set_caption}

\item \texttt{pygame.display.flip()}:
\index{\texttt{pygame}!\texttt{display}!\texttt{flip()}}\\
\url{https://www.pygame.org/docs/ref/display.html#pygame.display.flip}

\item \texttt{pygame.time.Clock}:
\index{\texttt{pygame}!\texttt{time}!\texttt{Clock}}\\
\url{https://www.pygame.org/docs/ref/time.html#pygame.time.Clock}

\item \texttt{pygame.time.Clock.tick()}:
\index{\texttt{pygame}!\texttt{time}!\texttt{Clock}!\texttt{tick()}}\\
\url{https://www.pygame.org/docs/ref/time.html#pygame.time.Clock.tick}

\item \texttt{pygame.time.Clock.tick\_busy\_loop()}:
\index{\texttt{pygame}!\texttt{time}!\texttt{Clock}!\texttt{tick\_busy\_loop()}}\\
\url{https://www.pygame.org/docs/ref/time.html#pygame.time.Clock.tick_busy_loop}

\item \texttt{pygame.event.get()}:
\index{\texttt{pygame}!\texttt{event}!\texttt{get()}}\\
\url{https://www.pygame.org/docs/ref/event.html#pygame.event.get}

\item \texttt{pygame.event.type}:
\index{\texttt{pygame}!\texttt{event}!\texttt{type}}\\
\url{https://www.pygame.org/docs/ref/event.html#pygame.event.EventType.type}

\item \texttt{pygame.QUIT}:
\index{\texttt{pygame}!\texttt{QUIT}}\\
\url{https://www.pygame.org/docs/ref/event.html#pygame.event.EventType.type}

\item \texttt{pygame.Surface.fill()}:
\index{\texttt{pygame}!\texttt{Surface}!\texttt{fill()}}\\
\url{https://www.pygame.org/docs/ref/surface.html#pygame.Surface.fill}
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Grafikprimitive}

\section{Beispiele}

Unter Grafikprimitiven versteht man gezeichnete einfache grafische Figuren wie Linien, Punkte, Kreise etc. Sie spielen in der Spieleprogrammierung nicht so eine große Rolle, können aber manchmal ganz nützlich sein. Ich will hier deshalb nur einige vorstellen. 

\lstsource{SRC/00 einführung/02 Primitive/primitives00.py}{1}{999}{python}{Mein zweites \emph{Spiel}, Version 1.0}{srcPrimitives00}

\myebild{primitives.png}{0.8}{Einige Grafikprimitve}{picPrimitive}


Der Grundaufbau ist der gleiche wie in \srcref[vref]{srcStart01}. Die Unterschiede beginnen in \zeiref{srcPrimitives01}. Die Klasse \texttt{pygame.Color}\randnotiz{Color}\index{\texttt{pygame}!\texttt{Color}} kann Farbinformationen in verschiedenen Formaten inklusive eines \glslink{alpha}{Alpha-Kanals}\index{Alpha-Kanal} (Transparenz); mehr dazu später. Ich verwende hier eine RGB-Kodierung mit Farbkanalwerten zwischen 0 und 255. 

Gehen wir der Reihe nach die einzelnen Figuren durch und fangen mit dem Rechteck an. Es gibt mehrere Möglichkeiten, ein Rechteck in Pygame zu bestimmen. Da wir es später auch sehr oft brauchen, möchte ich hier schonmal die Klasse \texttt{pygame.Rect}\index{\texttt{pygame}!\texttt{Rect}}\randnotiz{Rect} einführen. Sie wird durch vier Parameter bestimmt: die linke obere Ecke, seine Breite und seine Höhe. In \zeiref{srcPrimitives02} wird also ein Rechteck an der Position $(10,10)$ mit der Breite von $20px$ und einer Höhe von $30px$ definiert. 

Hinweis: Die Klasse \texttt{Rect} ist kein gezeichnetes Rechteck, sondern lediglich ein Kontainer für Informationen, die für ein Rechteck interessant sind. 

In \zeiref{srcPrimitives03} zeichnet \texttt{pygame.draw.rect()}\index{\texttt{pygame}!\texttt{draw}!\texttt{rect()}}\randnotiz{rect()} ein gefülltes Rechteck. Die \Gls{semantik} der Parameter sollte selbsterklärend sein. Anders der Aufruf von \zeiref{srcPrimitives04}. Der erste Parameter hinter dem Rechteck -- hier \texttt{3} -- legt die Dicke der Linie fest. Ist dieser Parameter angegeben und größer~0, so wird das Rechteck nicht mehr ausgefüllt. Der Wert~\texttt{10} legt die Rundung der Ecken fest. Dort kann ein Wert von 0 bis $min(width, height)/2$ stehen, enspricht er doch dem Radius der Eckenrundung.

Allgemeiner als ein Rechteck ist ein \Gls{polygon}. Ein Polygon ist ein geschlossener Lienenzug, der in Pygame durch seine Punkte (Ecken) definiert wird. Ähnlich wie bei den Rechtecken, gibt es gefüllte (\zeiref{srcPrimitives06}) und ungefüllte (\zeiref{srcPrimitives07}) Varianten. Beide werden mit Hilfe von \texttt{pygame.draw.polygon()}\randnotiz{polygon()}\index{\texttt{pygame}!\texttt{draw}!\texttt{polygon()}} gezeichnet. Vorsicht bei der Liniendicke: Diese wachsen nach außen, so dass bald hässliche Versatzstücke an den Ecken erkennbar werden. Probieren Sie es aus, indem Sie den Wert~\texttt{2} in~\texttt{5} ändern.

Für einzelne Linien gibt es \texttt{pygame.draw.line()}\index{\texttt{pygame}!\texttt{draw}!\texttt{line()}}\randnotiz{line()} bzw. für einen -- hier ohne Beispiel -- \gls{linienzug} \texttt{pygame.draw.lines()}\index{\texttt{pygame}!\texttt{draw}!\texttt{lines()}}\randnotiz{lines()}. Ein Beispiel finden Sie in \zeiref{srcPrimitives08}.

Ein Kreis wird durch zwei Angaben definiert: Mittelpunkt und Radius. In \zeiref{srcPrimitives09} wird mit \texttt{pygame.draw.circle()}\index{\texttt{pygame}!\texttt{draw}!\texttt{circle()}}\randnotiz{circle()} ein gefüllter Kreis mit dem Mittelpunkt $(40, 150)$ und einem Radius von $30px$ gezeichnet. Wie bei Rechtecken und Polygonen gibt es auch nicht gefüllte Varianten (\zeiref{srcPrimitives10}). Interessant ist der Kreisbogenausschnitt in \zeiref{srcPrimitives11}. Hier wird über boolsche Variablen gesteuert, welcher Abschnitt des Kreisbogens gezeichnet wird (näheres in der Pygame-Referenz).

Zum Schluss noch einen kleine Farbenspielerei. Seltsamerweise gibt es in Pygame keine eigene Funktion zum Zeichnen eines einzelnen Punktes/Pixel. Ich habe hier mal drei Workarounds programmiert, die ich gefunden habe. man könnte sich noch weitere überlegen: Eine Linie mit $start=ende$ oder ein Kreis mit dem Radius~1 usw.

In \zeiref{srcPrimitives12} wird der Punkt durch das Setzen eines einzelnen Farbwertes an einer Position mit \texttt{pygame.Surface.set\_at()}\index{\texttt{pygame}!\texttt{Surface}!\texttt{set\_at()}}\randnotiz{set\_at()} gezeichnet. Man könnte auch die schon oben verwendete Surface-Funktion \texttt{fill()} mit einer Ausdehnung von nur einem Pixel Breite und Höhe verwenden (\zeiref{srcPrimitives13}). Ein Möglichkeit einen Pixel über eine Grafikbibliothek zu setzen, ist die experimentelle \texttt{gfxdraw}-Umgebung. In \zeiref{srcPrimitives14} wird mit \texttt{pygame.gfxdraw.pixel()}\index{\texttt{pygame}!\texttt{gfxdraw}!\texttt{pixel()}}\randnotiz{pixel()} ein einzelnes Pixel gesetzt. Die \texttt{gfxdraw}-Umgebung wird nicht automatisch durch \texttt{import pygame} importiert (siehe \zeiref{srcPrimitives15}).

\section{Was war neu?}

\begin{itemize}
\item \texttt{import pygame.gfxdraw}:\\ \url{https://www.pygame.org/docs/ref/gfxdraw.html}

\item \texttt{import pygame.gfxdraw.pixel()}:\\ \url{https://www.pygame.org/docs/ref/gfxdraw.html#pygame.gfxdraw.pixel}

\item \texttt{pygame.Color}:
\index{\texttt{pygame}!\texttt{Color}}\\
\url{https://www.pygame.org/docs/ref/color.html}

\item \texttt{pygame.Rect}:
\index{\texttt{pygame}!\texttt{Rect}}\\
\url{https://www.pygame.org/docs/ref/rect.html}

\item \texttt{pygame.draw.rect()}:
\index{\texttt{pygame}!\texttt{draw}!\texttt{rect()}}\\
\url{https://www.pygame.org/docs/ref/draw.html#pygame.draw.rect}

\item \texttt{pygame.draw.polygon()}:
\index{\texttt{pygame}!\texttt{draw}!\texttt{polygon()}}\\
\url{https://www.pygame.org/docs/ref/draw.html#pygame.draw.polygon}

\item \texttt{pygame.draw.line()}:
\index{\texttt{pygame}!\texttt{draw}!\texttt{line()}}\\
\url{https://www.pygame.org/docs/ref/draw.html#pygame.draw.line}

\item \texttt{pygame.draw.lines()}:
\index{\texttt{pygame}!\texttt{draw}!\texttt{lines()}}\\
\url{https://www.pygame.org/docs/ref/draw.html#pygame.draw.lines}

\item \texttt{pygame.draw.circle()}:
\index{\texttt{pygame}!\texttt{draw}!\texttt{circle()}}\\
\url{https://www.pygame.org/docs/ref/draw.html#pygame.draw.circle}

\item \texttt{pygame.Surface.set\_at()}:
\index{\texttt{pygame}!\texttt{Surface}!\texttt{set\_at()}}\\
\url{https://www.pygame.org/docs/ref/surface.html#pygame.Surface.set_at}

\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Bitmaps laden und ausgeben}

\section{Beispiel}

\lstsource{SRC/00 einführung/03 Bitmaps/invader01.py}{1}{999}{python}{Bitmaps laden und ausgeben, Version 1.0}{srcInvader01}

In \srcref{srcInvader01} werden zwei Bitmaps -- hier zwei png-Dateien -- geladen und auf den Bildschirm ausgegeben. 

Das Laden erfolgt über die Funktion \texttt{pygame.image.load()}\index{\texttt{pygame}!\texttt{image}!\texttt{load()}}\randnotiz{load()}. In \zeiref{srcInvader0101}f. werden die Bitmaps geladen und in ein \texttt{Surface}-Objekt umgewandelt. Die beiden Bitmaps werden dann, ohne sie weiter zu verarbeiten, mit Hilfe von \texttt{pygame.Surface.blit()}\index{\texttt{pygame}!\texttt{Surface}!\texttt{blit()}}\randnotiz{blit()} auf das \texttt{screen}-Surface gedruckt (\zeiref{srcInvader0102}). Der erste Parameter von \texttt{blit()} ist das \texttt{Surface}-Objekt welches gedruckt werden soll und danach erfolgt die Angabe der Position. Dabei wird zuerst die horizontale (waagerechte) und dann die vertikale (senkrechte) Koordinate angegeben. Der 0-Punkt ist dabei anders als in der Schulmathematik nicht links unten, sondern links oben. Das Ergebnis können Sie in \abbref[vref]{picInvader01} \emph{bewundern}.

\myebild{invader01.png}{0.8}{Bitmaps laden und ausgeben, Version 1.0}{picInvader01}

Wir wollen nun die Bitmaps ein wenig unseren Bedürfnissen anpassen. Zunächst empfiehlt das Handbuch, dass das Bitmap nach dem Laden in ein für Pygame leichter zu verarbeitendes Format konvertiert wird. Darüber hinaus möchte ich die Größenverhältnisse der beiden Bitmaps angleichen, da mir der Enemy im Verhältnis zum Defender zu groß ist. 

\lstsource{SRC/00 einführung/03 Bitmaps/invader02.py}{19}{23}{python}{Bitmaps laden und ausgeben, Version 1.1}{srcInvader02}

Die Funktion \texttt{pygame.Surface.load()} lieferte mit ja ein \texttt{Surface}-Objekt zurück. Die Klasse \texttt{Surface} hat nun eine Methode, die mir die gewünschte Konvertierung vornimmt: \texttt{pygame.Surface.convert()}\index{\texttt{pygame}!\texttt{Surface}!\texttt{convert()}}\randnotiz{convert()}. Beispielhaft sei hier auf \zeiref{srcInvader0201} verwiesen. 

Das Verändern der Größe erfolgt durch \texttt{pygame.transform.scale()}\index{\texttt{pygame}!\texttt{transform}!\texttt{scale()}}\randnotiz{scale()}. In \zeiref{srcInvader0202} wird das Image auf die angegeben $(width, height)$ in der Maßeinheit Pixel skaliert. Das Ergebnis an \abbref{picInvader02} entspricht nicht ganz meinen Erwartungen.  

\begin{wrapfigure}{r}{5cm}
\myfigure{invader02.png}{0.8}{Größen OK}{picInvader02}
\end{wrapfigure}
Die Größenverhältnisse gefallen mir zwar jetzt, aber warum erscheint plötzlich ein schwarzer Hintergrund? Die Ursache dafür ist, dass durch die Konvertierung mit \texttt{convert()} die Information für die Transparenz\index{Transparenz} verloren gegangen ist. Die Transparenz steuert die \emph{Durchsichtigkeit} eines Pixels. Erreicht wird dies dadurch, dass zusätzlich zu jedem Pixel nicht nur die drei RGB-Werte, sondern auch eine Durchsichtigkeit abgespeichert wird. Diese zusätzliche Information nennt man den \emph{Alpha-Kanal}\index{Alpha-Kanal}\randnotiz{Alpha-Kanal}.

Ich habe nun zwei Möglichkeiten, diese Transparenz wieder verfügbar zu machen:
\begin{itemize}
	\item \texttt{pygame.Surface.convert\_alpha()}\index{\texttt{pygame}!\texttt{Surface}!\texttt{convert\_alpha()}}\randnotiz{convert\_alpha()}: Ganz einfach formuliert wird bei der Konvertierung der Alpha-Kanal erhalten. Wenn möglich, sollte das das Mittel Ihrer Wahl sein.
	
	\item \texttt{pygame.Surface.set\_colorkey()}\index{\texttt{pygame}!\texttt{Surface}!\texttt{set\_colorkey()}}\randnotiz{set\_colorkey()}: Als Übergabeparameter übergeben Sie die Farbe, die von Pygame beim Drucken auf das Ziel-Surface übersprungen werden soll. Dabei können zwei Nachteile entstehen. Zum einen können Transparenzen die zwischen sichtbar und unsichtbar liegen nicht abgebildet werden. Es wäre also nicht möglich, einen Pixel \emph{halbdurchscheinen} zu lassen. Zum anderen werden auch Teile des Figur, die die gleiche Farbe wie der Hintergrund haben, ebenfalls transparent erscheinen. Würde unser Alian in der Mitte ein schwarzes Auge haben, würde es verschwinden und der Alien hätte ein Loch in der Mitte.
\end{itemize}

\lstsource{SRC/00 einführung/03 Bitmaps/invader03.py}{19}{24}{python}{Bitmaps laden und ausgeben, Version 1.2}{srcInvader03}

\begin{wrapfigure}[10]{r}{5cm}
\myfigure{invader03.png}{0.8}{Transparenz OK}{picInvader03}
\end{wrapfigure}
In \srcref[vref]{srcInvader03} habe ich beide Varianten mal ausprobiert und in \abbref[vref]{picInvader03} können Sie das Ergebnis sehen. Nun sind beide Bitmaps wieder ohne schwarze Umrandung sichtbar, der weiße Hintergrund scheint wieder durch.

Was mir nun noch nicht gefällt ist die Position und die Anzahl der Angreifer. Ich möchte den Verteidiger mittig unten platzieren und die Angreifer am oberen Bildschirmrand und zwar so, dass sie horizontal  \gls{aequidistant}\index{äquidistant}\randnotiz{äquidistant} sind. Dabei gibt es zwei Möglichkeiten: ich gebe einen Mindestabstand an und die Anzahl wird ausgerechnet, oder ich gebe die maximale Anzahl an und die Abstand wird ausgerechnet. Welchen Weg ich wähle, hängt von meiner Spiellogik ab; meist ist die Anzahl vorgegeben.

\lstsource{SRC/00 einführung/03 Bitmaps/invader04.py}{1}{999}{python}{Bitmap: Positionen, Version 1.4}{srcInvader04}

In \srcref[vref]{srcInvader04} sind die obigen Anforderungen umgesetzt worden. Schauen wir uns die einzelnen Aspekte genauer an.

Der Verteidiger sollte unten mittig positioniert werden. Wir erinnern uns, dass der Funktion \texttt{blit()} auch die Koordinaten der linken oberen Ecke mitgegeben werden. 

Diese Angabe muss erst berechnet werden. Der Übersichtlichkeit wegen -- in einem normalen Quelltext würde ich die Berechnung nicht so kleinteilig programmieren -- berechne ich hier die Koordinaten einzeln.

Die obere Kante ist dabei recht einfach zu ermitteln. Würden wir \texttt{defender\_top} auf die gesamte Höhe des Bildschirms \texttt{Settings.windows\_height} setzen, würden wir den Verteidiger nicht sehen, da er komplett unten aus dem Bildschirm rausragen würden. Um wie viele Pixel müssen wir also die obere Kante anheben? Genau um die Höhe des Raumschiffs, $30px$:

\lstset{firstnumber=24}
\begin{lstlisting}
defender_pos_top = Settings.window_height - 30
\end{lstlisting}

Mir gefällt dabei aber nicht, dass der Verteidiger dabei so an den Rand angeklebt aussieht. Ich spendiere ihm noch weitere $5px$, damit er mehr danach aussieht, im Raum zu schweben:

\lstset{firstnumber=24}
\begin{lstlisting}
defender_pos_top = Settings.window_height - 30 - 5
\end{lstlisting}

In \zeiref{srcInvader0401} wird der Abstand des linken Rands des Bitmaps vom Spielfeldrand berechnet. Mit

\lstset{firstnumber=23}
\begin{lstlisting}
defender_pos_left = Settings.window_width // 2
\end{lstlisting}

würden wir die horizontale Mitte des Bildschirmes ausrechnen. Diesen Wert können wir aber nicht einsetzen, da dann der linke Rand des Verteidigers in der horizontalen Mitte stehen würde -- also zu weit rechts (siehe \abbref[vref]{picInvader04a}). 

\myebild{invader04a.png}{0.7}{Bitmaps positionieren (Verteidiger)}{picInvader04a}

Die Anzahl der Pixel, die wir zu weit nach rechts gerutscht sind, können wir aber genau bestimmen und dann abziehen: Es ist genau die Hälfte der Breite des Verteidigers (hier $30px$):
\begin{lstlisting}
defender_pos_left = Settings.window_width // 2 - 30 // 2
\end{lstlisting}

Mit Hilfe von ein wenig Bruchrechnen lässt der Ausdruck vereinfachen:
\begin{lstlisting}
defender_pos_left = (Settings.window_width - 30) // 2
\end{lstlisting}

Jetzt kommen die Angreifer. Im ersten Ansatz wollen wir diese hintereinander ohne Überschneidungen oben ausgeben. Die obere Kante \texttt{alien\_top} können wir konstant mit einem angenehmen Abstand von $10px$ vom oberen Rand setzen:

\lstset{firstnumber=44}
\begin{lstlisting}
alien_top = 10 
\end{lstlisting}

Die linke Position \texttt{alien\_left} muss für jedes Alien einzeln bestimmt werden. Da diese direkt erstmal nebeneinander liegen, ist ein linker Rand genau die Breite eines Aliens vom nächsten linken Rand entfernt. Wenn ich also beim $0ten$ Alien bin, liegt die horizontale Koordinate direkt am linken Bildschirmrand. Beim $1ten$ Alien genau $1\times50px$, beim $2ten$ genau $2\times50px$ usw., da die Breite des Aliens $50px$ beträgt. In eine for-Schleife gegossen, sieht das so aus:

\lstset{firstnumber=45}
\begin{lstlisting}
for i in range(Settings.aliens_nof):
    alien_left = i * 50
    alien_pos = (alien_left, alien_top)
    screen.blit(alien_image, alien_pos)
\end{lstlisting}


\myebild{invader04b.png}{0.8}{Bitmaps positionieren (Angreifer, Version 1)}{picInvader04b}


Der ganze Platz hinter dem letzten Alien kann jetzt aber vor, zwischen und nach den Aliens verteilt werden und zwar so, dass zwischen den Aliens, dem linken Alien und dem linken Bildschirmrand und dem rechten Alien und dem rechten Bildschirmrand immer gleich viel Abstand liegt. Wie viele Zwischenräume sind es denn? Nun einmal die beiden ganz rechts und ganz links, also 2:

\lstset{firstnumber=31}
\begin{lstlisting}
space_nof = 2  
\end{lstlisting}

Dann die Anzahl der Zwischenräume zwichen den Aliens. Dies sind immer 1 weniger als Aliens (zählen Sie nach!):

\lstset{firstnumber=31}
\begin{lstlisting}
space_nof = Settings.aliens_nof - 1 + 2
\end{lstlisting}

also:

\lstset{firstnumber=31}
\begin{lstlisting}
space_nof = Settings.aliens_nof + 1     
\end{lstlisting}

Nun muss der verfügbare Platz \texttt{space\_availible} hinter den Aliens noch ausgerechnet werden. Ich erreiche dies, indem ich den Platz, den Aliens verbrauchen, \texttt{space\_for\_aliens} ausrechne

\lstset{firstnumber=29}
\begin{lstlisting}
space_for_aliens =  Settings.aliens_nof * 50     
\end{lstlisting}

und dies von der Bildschirmbreite abziehe.
\lstset{firstnumber=30}
\begin{lstlisting}
space_availible = Settings.window_width - space_for_aliens
\end{lstlisting}

Ich habe also den verfügbaren Platz in \texttt{space\_availible} und die Anzahl der Räume, die gefüllt werden müssen in \texttt{space\_nof}. Wenn ich jetzt die Breite der Räume \texttt{space\_between\_\-aliens} ermitteln will, muss ich diese beiden Werte dividieren:

\lstset{firstnumber=32}
\begin{lstlisting}
space_between_aliens = space_availible // space_nof
\end{lstlisting}

Jetzt müssen wir nur noch die Berechnung von \texttt{alien\_left} anpassen. Erstmal verschieben wir den Start um einen solchen Freiraum (siehe \abbref[vref]{picInvader04c}):

\lstset{firstnumber=45}
\begin{lstlisting}
for i in range(Settings.aliens_nof):
    alien_left = space_between_aliens + i * 50
    alien_pos = (alien_left, alien_top)
    screen.blit(alien_image, alien_pos)
\end{lstlisting}

\myebild{invader04c.png}{0.8}{Bitmaps positionieren (Angreifer, Version 2)}{picInvader04c}

Nun muss der Abstand von einem linken Rand zum anderen, der bisher nur aus der Breite des Aliens bestand, um den Abstand \texttt{space\_between\_aliens} erweitert werden:

\lstset{firstnumber=45}
\begin{lstlisting}
for i in range(Settings.aliens_nof):
    alien_left = space_between_aliens + i * (space_between_aliens + 50)
    alien_pos = (alien_left, alien_top)
    screen.blit(alien_image, alien_pos)
\end{lstlisting} 

Und schon passt alles (siehe \abbref[vref]{picInvader04d}).

\myebild{invader04d.png}{0.8}{Bitmaps positionieren (Angreifer, Version 3)}{picInvader04d}

\section{Was war neu?}

Zum Abschluss möchte hier einen kurze Zusammenfassung darüber geben, was wir hier an Informationen erworben haben:

\begin{itemize}
    \item Die Positionsangaben werden bei der Ausgabe auf dem Bildschirm benötigt. Wir werden später sehen, dass wir die Positionsangaben auch noch für andere Fragestellungen brauchen, wie beispielsweise die \Gls{kollsionserkennung}Kollisionserkennung.

    \item Die Positionsangabe bezieht sich immer auf die linke obere Ecke des Bitmaps. 

    \item Das Koordinatensystem hat seinen 0-Punkt linksoben und nicht linksunten.

    \item Wir müssen häufig elementare Geometrieberechnungen durchführen und am besten macht man diese Schritt für Schritt.

    \item Für solche Geometrieberechnungen werden folgende Informationen gebraucht: die Position des Bitmap, seine Breite und Höhe. Breite und Höhe haben wir hier noch als Konstanten verarbeitet, dass ist nicht zukunftsweisend.
\end{itemize}

Und hier die neuen Klassen bzw. Funktionen:

\begin{itemize}
\item \texttt{pygame.image}
\index{\texttt{pygame}!\texttt{image}}:\\
\url{https://www.pygame.org/docs/ref/image.html}

\item \texttt{pygame.image.load()}
\index{\texttt{pygame}!\texttt{image}!\texttt{load()}}:\\
\url{https://www.pygame.org/docs/ref/image.html#pygame.image.load}

\item \texttt{pygame.Surface.blit()}:
\index{\texttt{pygame}!\texttt{Surface}!\texttt{blit()}}\\
\url{https://www.pygame.org/docs/ref/surface.html#pygame.Surface.blit}

\item \texttt{pygame.Surface.convert()}:
\index{\texttt{pygame}!\texttt{Surface}!\texttt{convert()}}\\
\url{https://www.pygame.org/docs/ref/surface.html#pygame.Surface.convert}

\item \texttt{pygame.Surface.convert\_alpha()}:
\index{\texttt{pygame}!\texttt{Surface}!\texttt{convert\_alpha()}}\\
\url{https://www.pygame.org/docs/ref/surface.html#pygame.Surface.convert\_alpha}

\item \texttt{pygame.Surface.set\_colorkey()}:
\index{\texttt{pygame}!\texttt{Surface}!\texttt{set\_colorkey()}}\\
\url{https://www.pygame.org/docs/ref/surface.html#pygame.Surface.set\_colorkey}

\item \texttt{pygame.transform.scale()}:
\index{\texttt{pygame}!\texttt{transform}!\texttt{scale()}}\\
\url{https://www.pygame.org/docs/ref/transform.html#pygame.transform.scale}

\end{itemize}

